#!/usr/bin/env python
# coding: utf-8

# In[1]:


#!pip install seaborn


# **Исследование объявлений о продаже квартир**

# В вашем распоряжении данные сервиса Яндекс Недвижимость — архив объявлений за несколько лет о продаже квартир в Санкт-Петербурге и соседних населённых пунктах.
# 
# Ваша задача — выполнить предобработку данных и изучить их, чтобы найти интересные особенности и зависимости, которые существуют на рынке недвижимости.
# 
# О каждой квартире в базе содержится два типа данных: добавленные пользователем и картографические. Например, к первому типу относятся площадь квартиры, её этаж и количество балконов, ко второму — расстояния до центра города, аэропорта и ближайшего парка. 

# **Описание данных:**
# 
# - `airports_nearest` — расстояние до ближайшего аэропорта в метрах (м)
# - `balcony` — число балконов
# - `ceiling_height` — высота потолков (м)
# - `cityCenters_nearest` — расстояние до центра города (м)
# - `days_exposition` — сколько дней было размещено объявление (от публикации до снятия)
# - `first_day_exposition` — дата публикации
# - `floor` — этаж
# - `floors_total` — всего этажей в доме
# - `is_apartment` — апартаменты (булев тип)
# - `kitchen_area` — площадь кухни в квадратных метрах (м²)
# - `last_price` — цена на момент снятия с публикации
# - `living_area` — жилая площадь в квадратных метрах (м²)
# - `locality_name` — название населённого пункта
# - `open_plan` — свободная планировка (булев тип)
# - `parks_around3000` — число парков в радиусе 3 км
# - `parks_nearest` — расстояние до ближайшего парка (м)
# - `ponds_around3000` — число водоёмов в радиусе 3 км
# - `ponds_nearest` — расстояние до ближайшего водоёма (м)
# - `rooms` — число комнат
# - `studio` — квартира-студия (булев тип)
# - `total_area` — общая площадь квартиры в квадратных метрах (м²)
# - `total_images` — число фотографий квартиры в объявлении

# ### 1. Откройте файл с данными и изучите общую информацию. 

# **Импортируем необходимые библиотеки и загружаем данные из файла в датафрейм:**

# In[2]:


import pandas as pd

import seaborn as sns
import matplotlib.pyplot as plt


# In[3]:


try:
    data = pd.read_csv('C:/Users/Acer/Desktop/пятый спринт/real_estate_data.csv', sep='\t')
except:
    data = pd.read_csv('https://code.s3.yandex.net/datasets/real_estate_data.csv', sep='\t')


# **Рассмотрим полученные данные из датафрейма:**

# In[4]:


# Выведем первые 5 строк датафрейма
data.head()


# In[5]:


# Выведем основные характеристика датафрейма (типы столбцов, пропущенные значения)
data.info()


# Вывод: Всего в датафрейме 23 699 объявлений о продаже квартир и 22 столбца, в более половине которых пропущены значения. Также можно отметить, что значения столбца `is_apartment` не соответствуют булеву типу, а значения столбца`first_day_exposition` не соответствуют типу данных datetime. Тип данных столбцов `floors_total`, `balcony`, `parks_nearest`, `ponds_nearest` и `days_exposition` следует изменить на целочисленный.

# ### 2. Предобработка данных

# In[6]:


# Создадим функцию, которая подсчитывает и выводит количество пропущенных значений в столбцах
def missing_value(data, col):
    if data[col].count() != max(data.count()):
        print(f'В столбце {col} пропущено {data[col].isna().sum()} значений'
              f'({data[col].isna().sum() / max(data.count()):.2%})'
              f' от общего числа объявлений')


# In[209]:


# Напишем функцию для отображения гистограмм и диаграмм размаха в одной ячейке:
def figure_two(figure, kde):
    fig, (ax1, ax2) = plt.subplots(1, 2, figsize = (10, 7))
    sns.histplot(data[figure], 
                 discrete=True, 
                 binwidth=10, 
                 color=sns.color_palette('deep')[0], 
                 bins=100,
                 ax=ax1,
                 kde=kde
    ).grid(axis='x')
    sns.set_style("whitegrid")
    
    sns.boxplot(data[figure], ax=ax2, color=sns.color_palette('deep')[0])
    sns.set_style("whitegrid")
    plt.xlabel(figure, fontsize=10)


# **Рассмотрим каждый отдельный столбец и заполним пропущенные значения там, где это возможно.**

# **1. Столбец `ceiling_height` - высота потолков (м)**

# In[8]:


# Рассмотрим основные характеристика столбца:
data['ceiling_height'].describe()


# In[9]:


missing_value(data, 'ceiling_height')


# Отметим, что максимальное зачение в столбце составляет 100 метров, а минимальное - 1 метр.

# In[10]:


figure_two('ceiling_height', False)


#  Судя по графикам, в столбце `ceiling_height` присутствуют значения высоты потолка от 15. Найдем количество квартир с высотой потолков больше 15 метров:

# In[11]:


data[data['ceiling_height'] > 15]['ceiling_height'].count()


# Так как маловероятно, что существуют квартиры с высотой потолков более 15 метров, предположим, что в данных 23 значениях была допущена ошибка и значения должны быть в 10 раз меньше:

# In[12]:


data.loc[data['ceiling_height'] > 15, 'ceiling_height'] = data['ceiling_height'] / 10


# Минимальное значения высоты потолка в данных - 1 метр. Так как данное значение также маловероятно можно найти в обычных жилых квартирах, проверим, присутствуют ли значения с высотой потолка менее 2.5 метров:

# In[13]:


data[data['ceiling_height'] < 2.5].sort_values(by='last_price', ascending=False).head()


# In[14]:


data[data['ceiling_height'] < 2.5]['ceiling_height'].count()


# Таких квартир целых 76. Исходя из невысокой цены в столбце `last_price`, мы не можем увеличить высоту потолка, например, в 10 раз. Так как таких квартир всего три, заменим значения в данных объявлениях на медианное:

# In[15]:


data.loc[data['ceiling_height'] < 2.5, 'ceiling_height'] = data['ceiling_height'].median()


# In[16]:


data['ceiling_height'].describe()


# Посмотрим, существует ли зависимость между значениями столбца `ceiling_height` и значениями других столбцов датфрейма:

# In[212]:


data.corr()['ceiling_height'].sort_values(ascending=False)


# Явной зависимости не наблюдается. 
# Причиной столь большого количества пропусков может быть то, что авторы публикаций посчитали данное значение стандратным. В случае больших значений потолка, авторы обязательно указали бы данное значение, так как это является плюсом для квартиры.
# В многоквартирных домах России в зависимости от регинона стандартное значение потолка должно быть не ниже 2,5 м или 2,7 м. Медиана столбца `ceiling_height` равна 2.65. В столбце `ceiling_height` разброс значений достаточно большой, поэтому заполним данным значением медианы все пропуски:

# In[18]:


data['ceiling_height'] = data['ceiling_height'].fillna(value=data['ceiling_height'].median())


# Проверим, остались ли пропуски в столбце `ceiling_height`:

# In[19]:


data['ceiling_height'].isna().sum()


# In[20]:


# Рассмотрим изменение основных характеристик столбца:
data['ceiling_height'].describe()


# Пропусков нет. Посмотрим, как изменились графики:

# In[21]:


figure_two('ceiling_height', False)


# Так как мы заполнили пропуски медианой, увеличилось число публикаций со значением 2.65 м, что подтверждается гистограммой. Так же можно заметить, что минимальные значения стали равны 2,5 метрам.

# **2. Столбец `floors_total` — всего этажей в доме**

# In[22]:


data['floors_total'].describe()


# In[23]:


missing_value(data, 'floors_total')


# In[24]:


figure_two('floors_total', True)


# Отрицательных значений нет, выбросов немного. Этажность домов от 30 этажей вполне возможна в больших городах. Достаточно много 4-этажных и 10-этажных домов.

# Строк с пропущенными значениями не так много, поэтому пока оставим данные строки.

# **3. Столбец `living_area` - жилая площадь в квадратных метрах (м²)**

# In[27]:


data['living_area'].describe()


# In[28]:


missing_value(data, 'living_area')


# In[29]:


figure_two('living_area', True)


# Рассмотрим объявления с квартирами с жилой площадью в 270 кв.м, так как в соответствии с диаграммой размаха, таких объявлений-выбросов немного и они расположены выше максимального значения :

# In[30]:


data[data['living_area'] > 270]


# В столбце `last_price` и `total_area` можно заметить достаточно большие значения, что объяснимо: квартиры с большей площадью стоят дороже. Допустим, что такие квартиры существуют.

# In[211]:


data.corr()['living_area'].sort_values(ascending=False)


# Наблюдается сильная зависимость между значениями столбцов `living_area` и `total_area`. Отобразим ее на диаграмме рассеяния:

# In[32]:


sns.scatterplot(data=data, x='living_area', y='total_area', color=sns.color_palette('deep')[0])
sns.set_style("whitegrid")
plt.xlabel("Living area")
plt.ylabel("Total area")
plt.title("Living area ~ Total area")


# Найдем коэффициент для дальнейшего заполнения пропущенных значений путем нахождения среднего от деления столбца `living_area` на `total_area`:

# In[33]:


(data['living_area'] / data['total_area']).mean()


# С помощью найденного коэффициента, заполним столбец `living_area`:

# In[34]:


data.loc[data['living_area'].isna(), 'living_area'] = ((data['living_area'] / data['total_area']).mean())                                                         * data['total_area']


# In[35]:


# Округляем значения столбца до двух знаков после запятой
data['living_area'] = round(data['living_area'], 2)


# In[36]:


data['living_area'].isnull().sum()


# In[37]:


data['living_area'].describe()


# Медианное и среднее значения практически не изменились. От пропусков избавились.

# **4. Столбец `is_apartment` - апартаменты (булев тип)**

# In[38]:


data['is_apartment'].unique()


# In[39]:


missing_value(data, 'is_apartment')


# Заметим, что тип данных столбца не соответствует изначально заявленному - из-за наличия пропусков тип данных изменился на object. Скорее всего, это не ошибка, просто авторы не заполнили данный столбец, так как квартира не является апартаментами, да и сами апартаменты не часто встретишь даже в больших городах. Поэтому заменим пропущенные значения на *False* - то есть обозначим данные объявления как не апартаменты:

# In[40]:


data['is_apartment'] = data['is_apartment'].fillna(value=False)


# In[41]:


data['is_apartment'].unique()


# Теперь весь столбец заполнен значениями булева типа - True/False.

# **5. Столбец `kitchen_area` -  площадь кухни в квадратных метрах (м²)**

# In[42]:


data['kitchen_area'].describe()


# In[43]:


missing_value(data, 'kitchen_area')


# В датафрейме есть столбец `studio` со значениями булева типа. В квартирах-студиях обычно кухни как таковой нет, поэтому заменим значение столбца kitchen_area в строках, в которых значение столбца `studio` равно *True*, на 0.

# In[44]:


data.loc[data['studio'] == True, 'kitchen_area'] = data['kitchen_area'].fillna(value=0)


# In[45]:


data['kitchen_area'].isna().sum()


# Теперь пропущенных значений стало 2129.

# Определим, есть ли зависимость значений столбца kitchen_area от остальных столбцов:

# In[210]:


data.corr()['kitchen_area'].sort_values(ascending=False)


# Наибольшая зависимость у столбца `kitchen_area` - со столбцом `total_area`, но не настолько сильная, чтобы заполнить пропущенные значения тем же способом, что и в случае со столцом `living_area`. Попробуем применить категоризацию данных в зависимости от значений столбца `total_area`

# In[47]:


#Напишем функцию для категоризации данных в зависимости от значений столбца total_area
def categorize_area(area):
    try:
        if 0 <= area <= 40:
            return 'small'
        elif 40.01 <= area <= 90:
            return 'medium'
        elif 90.01 <= area <= 150:
            return 'large'
        elif area >= 150.1:
            return 'extra-large'
    except:
        pass


# In[48]:


data['total_area_category'] = data['total_area'].apply(categorize_area)


# Определим медиану во всех категориях и присвоим данные медианные значения в зависимости от категории там, где есть пропуски в столбце kitchen_area

# In[49]:


for i in data['total_area_category'].unique():
    data.loc[(data['total_area_category'] == i) & (data['kitchen_area'].isna()), 'kitchen_area'] =     data.loc[(data['total_area_category'] == i), 'kitchen_area'].median()


# In[50]:


data['kitchen_area'].isna().sum()


# Теперь пропусков нет.

# In[51]:


data['kitchen_area'].describe()


# Минимальное значение теперь составляет 0 кв.м., так как присвоили данное значение квартирам-студиям. Соответственно, медиана стала чуть меньше.

# **6. Столбец `balcony` - число балконов**

# In[52]:


data['balcony'].describe()


# In[53]:


missing_value(data, 'balcony')


# Чаще всего в квартирах есть 1 балкон, максимальное количество балконов - 5.
# 
# Будем считать, что если автор публикации не указал число балконов, то, скорее всего, в его квартире их нет. Такие пропуски  заменим на 0

# In[54]:


data.loc[data['balcony'].isnull(), 'balcony'] = data['balcony'].fillna(value=0)


# In[55]:


data['balcony'].isnull().sum()


# In[56]:


data['balcony'].describe()


# In[57]:


figure_two('balcony', False)


# Теперь самое частотное значение - нулевое, так как заменили пропущенные значения на ноль. Меньше всего квартир с 3 балконами. Медиана стала равна нулю.

# **7. Столбец `locality_name` - название населённого пункта**

# In[58]:


missing_value(data, 'locality_name')


# Пропущенных значений не много, заменим пропуски на значение 'другие'.

# In[59]:


data.loc[data['locality_name'].isna(), 'locality_name'] = 'другие'


# In[60]:


data['locality_name'].isna().sum()


# От пропусков избавились.

# Так как авторы могут по-разному указывать название населенного пункта, а также возможны ошибки при заполнении, необходимо найти неявные дубликаты:

# In[61]:


# Переводим наименования пунктов в нижний регистр, заменяем букву 'ё' на 'е', а 'городской поселок'
# на 'поселок городского типа'
data['locality_name'] = data['locality_name'].str.lower()
data['locality_name'] = data['locality_name'].str.replace('ё', 'е')
data['locality_name'] = data['locality_name'].str.replace('городской поселок', 'поселок городского типа')


# In[62]:


# Выводим уникальные значения столбца locality_name
data['locality_name'].unique()


# Добавим в список элементы строк, в которых нет пробелов:

# In[63]:


list = []
for i in data['locality_name'].unique():
    if ' ' not in i and i in data['locality_name'].unique():
        list.append(i)  


# Заменим значения в столбце locality_name на элементы list при условии, что они входят в наименования столбца locality_name

# In[64]:


for i in list:
    for j in data['locality_name'].unique():
        if i in j:
            data['locality_name'] = data['locality_name'].str.replace(j, i)


# In[65]:


# Находим число уникальных значений
data['locality_name'].nunique()


# Заполнили все пропуски и обработали столбец на неявные дубликаты.

# **8. Столбец `airports_nearest` - расстояние до ближайшего аэропорта в метрах (м)**

# In[66]:


data['airports_nearest'].describe()


# In[67]:


missing_value(data, 'airports_nearest')


# Значения данного столбца заполнялись не авторами публикаций, а брались из картографической данных. Пропуски могут быть вызваны как технической ошибкой, так и тем фактом, что в некоторых случаях аэропорты могут располагаться далеко от местоположения квартиры.

# In[68]:


data['locality_name'].value_counts().head()


# In[69]:


data[data['airports_nearest'].isna()]['locality_name'].value_counts().head()


# Можно предположить, что произошла техническая ошибка - например, почти во всех имеющихся объявлениях с местоположением в Мурино и Кудрово нет информации о расстоянии до аэропорта. Так как исправить это вручную может занять очень много времени, а удалить строки с пропусками может исказить дальнейший анализ, оставим данные пропуски как есть.

# **9. Столбец `cityCenters_nearest` - расстояние до центра города (м)**

# In[70]:


data['cityCenters_nearest'].describe()


# In[71]:


missing_value(data, 'cityCenters_nearest')


# In[72]:


data[data['cityCenters_nearest'].isna()]['locality_name'].value_counts().head()


# Можно отметить, что в столбце cityCenters_nearest имеются пропуски в тех же населенных пунктах, что и в столбце airports_nearest. Скорее всего, это все же техническая ошибка. Пропуски оставим.

# **10. Столбец `parks_around3000` - число парков в радиусе 3 км**

# In[73]:


data['parks_around3000'].describe()


# In[74]:


missing_value(data, 'parks_around3000')


# In[75]:


figure_two('parks_around3000', False)


# In[76]:


data[data['parks_around3000'].isna()]['locality_name'].value_counts().head()


# Можно отметить, что в столбце parks_around3000 имеются пропуски в тех же населенных пунктах, что и в столбце airports_nearest, также процент пропусков практически совпадает. Скорее всего, это все же техническая ошибка. Пропуски оставим.

# **11. Столбец `parks_nearest` - расстояние до ближайшего парка (м)**

# In[77]:


data['parks_nearest'].describe()


# In[78]:


missing_value(data, 'parks_nearest')


# In[79]:


figure_two('parks_nearest', False)


# In[80]:


data[data['parks_nearest'].isna()]['locality_name'].value_counts().head()


# В данном столбце несколько отличаются пропущенные значения, например, большинство пропусков теперь в Санкт-Петербурге. Пока оставим пропуски, возможно, в дальнейшем данный столбец не понадобится.

# **12. Столбец `ponds_around3000` - число водоёмов в радиусе 3 км**

# In[81]:


data['ponds_around3000'].describe()


# In[82]:


missing_value(data, 'ponds_around3000')


# In[83]:


figure_two('ponds_around3000', False)


# In[84]:


data[data['ponds_around3000'].isna()]['locality_name'].value_counts().head()


# Можно отметить, что в столбце ponds_around3000 имеются пропуски в тех же населенных пунктах, что и в столбце airports_nearest, также процент пропусков практически совпадает. Скорее всего, это все же техническая ошибка. Пропуски оставим.

# **13. Столбец `ponds_nearest` - расстояние до ближайшего водоёма (м)**

# In[85]:


data['ponds_nearest'].describe()


# In[86]:


missing_value(data, 'ponds_nearest')


# In[87]:


figure_two('ponds_nearest', False)


# In[88]:


data[data['ponds_nearest'].isna()]['locality_name'].value_counts().head()


# В данном столбце отличаются пропущенные значения, например, большинство пропусков теперь в Санкт-Петербурге. Пока оставим пропуски, возможно, в дальнейшем данный столбец не понадобится.

# **14. Столбец `days_exposition` - сколько дней было размещено объявление (от публикации до снятия)**

# In[89]:


data['days_exposition'].describe()


# In[90]:


missing_value(data, 'days_exposition')


# In[91]:


data['days_exposition'].value_counts().head(10)


# Интересно, что наиболее часто встречающиеся значения выпали на 45 (1,5 месяца), 60 (месяц), 7 (неделя), 30 (месяц), 90 дней (три месяца). Такое могло быть при таких настройках, при которых объявления автоматически архивировались по прошествии определенного количества дней. 
# 
# В 3181 объявлении имеются пропуски. Причин может быть несколько: либо это все еще актуальные объявления, либо именно в данных ячейках произошла техническая ошибка и дни не были заполнены.
# 
# Попробуем найти самую позднюю дату в столбце first_day_exposition, в котором все значения заполнены. Сначала переведем столбец first_day_exposition в тип данных to_datetime

# In[92]:


# Переводим столбец first_day_exposition в тип данных to_datetime
data['first_day_exposition'] = pd.to_datetime(data['first_day_exposition'], format='%Y-%m-%dT%H:%M:%S')


# In[93]:


max(data['first_day_exposition'])


# Самая поздняя дата - 3 мая 2019 года. Предположим, что это может быть датой выгрузки всех объявлений

# In[94]:


data.loc[data['days_exposition'].isna(), 'days_exposition'] = data['days_exposition'] .fillna(value=(max(data['first_day_exposition']) - data['first_day_exposition']).astype('timedelta64[D]'))


# In[95]:


data['days_exposition'].isna().sum()


# In[96]:


data['days_exposition'].describe()


# После обработки данных, минимальное значение стало равно 0. Возможно, в дальнейшем потребуется удалить данные значения. Медианное значение уменьшилось на 1 пункт, так как стало больше нулевых значений.

# **Вывод - обработали пропущенные значения в следующих столбцах:**
# - `ceiling_height` (высота потолков (м)) - заполнили пропущенные значения (9195), а также значения до 2.5 метров медианой 2.65 метров, так как это согласуется с тем, что в многоквартирных домах России в зависимости от региона стандартное значение потолка должно быть не ниже 2,5 м или 2,7 м. Значения потолков от 15 метров уменьшили в 10 раз.
# - `floors_total` (всего этажей в доме) - оставили  86 пропущенных значений ввиду их малого количества и недостаточной корреляции с другими столбцами.
# - `living_area` (жилая площадь в квадратных метрах (м²)) - с помощью коэффициента среднего от деления столбца living_area на total_area в связи с сильной корреляцией между данными столбцами заполнили все 1903 пропуска
# - `is_apartmen` (апартаменты) - заполнили 20924 пропусков типом False (не апартаменты), так как скорее всего, авторы публикаций не заполняли данный столбец, если квартира не являлась апартаментами.
# - `kitchen_area` (площадь кухни в квадратных метрах (м²)) - заполнили 2278 пропусков медианными значениями по категориям общей площади, а также нулевыми значениями в случае, когда квартира является студией
# - `balcony` (число балконов) - пропущенные значения (11919) заполнили нулями, так как авторы публикаций, вероятно, оставили данное поле пустым в случае отсутствия балконов в квартире.
# - `locality_name` (название населённого пункта) - пропущенные значения, их всего 49, отнесли к категории 'другие'. Также избавились от неявных дубликатов.
# - `airports_nearest` (расстояние до ближайшего аэропорта в метрах (м)), `cityCenters_nearest` (расстояние до центра города (м)), `parks_around3000` (число парков в радиусе 3 км), `parks_nearest` (расстояние до ближайшего парка (м)), `ponds_around3000` (число водоёмов в радиусе 3 км), `ponds_nearest` (расстояние до ближайшего водоёма (м)) - оставили пропущенные значения, так как они вызваны технической ошибкой - в столбце cityCenters_nearest, ponds_around3000  и parks_around3000 имеются пропуски в тех же населенных пунктах, что и в столбце airports_nearest; в столбцах parks_nearest и ponds_nearest пропцщены значения в тех же населенных пунктах, а так же доля пропущенных значений приблизительно равна.
# - `days_exposition` (сколько дней было размещено объявление (от публикации до снятия)) - 3181 пропуск заполнили разницей между самым поздним днем в столбце first_day_exposition (день публикации) и значением столбца first_day_exposition для каждой строки. Выявлено, что наиболее часто встречающиеся значения выпали на 45 (1,5 месяца), 60 (месяц), 7 (неделя), 30 (месяц), 90 дней (три месяца). Такое могло быть при таких настройках, при которых объявления автоматически архивировались по прошествии определенного количества дней.

# ### 3. Преобразуем типы данных и добавим новые столбцы

# In[97]:


# Выведем общую информацию о датафрейме
data.info()


# In[98]:


# Переводим ц елочисленные значения столбцы balcony, days_exposition
data['balcony'] = data['balcony'].astype('int')
data['days_exposition'] = data['days_exposition'].astype('int')
try:
    data['parks_around3000'] = data['parks_around3000'].astype('int')
    data['ponds_around3000'] = data['ponds_around3000'].astype('int')
    data['floors_total'] = data['floors_total'].astype('int')
except:
    pass


# Тип данных в столбце floors_total изменим, когда обработаем пропущенные значения.

# In[99]:


# Добавим новые столбцы: цена за квадратный метр, день недели, месяц и год даты публикации
data['square_meter_price'] = data['last_price'] / data['total_area']
data['day_of_week'] = data['first_day_exposition'].dt.dayofweek
data['month'] = data['first_day_exposition'].dt.month
data['year'] = data['first_day_exposition'].dt.year


# In[100]:


# Напишем функцию для категоризации расположения полов в квартирах
def type_floor(data):
    try:
        total_floor = data['floors_total']
        floor = data['floor']
        if floor == 1:
            return 'первый'
        elif (total_floor - floor) == 0:
            return 'последний'
        else:
            return 'другой'
    except:
        return 'нет данных'


# In[101]:


# Применяем функцию type_floor
data['type_floor'] = data.apply(type_floor, axis=1)


# In[102]:


# Переводим значения столбца cityCenters_nearest их метров в километры и округляем до целого
data['cityCenters_nearest'] = round(data['cityCenters_nearest'] / 1000, 0)


# ### Удалим редкие и выбивающиеся значения

#  - Рассмотрим столбец floors_total:

# In[103]:


missing_value(data, 'floors_total')


# Так как выраженной корреляции значений из столбца floors_total с другими столбцами не наблюдается, удалим строки с пропусками:

# In[104]:


data = data.dropna(subset=['floors_total'])


#  - Рассмотрим столбцы kitchen_area, living_area и total_area:
# 
# Сумма жилой площади и площадь кухни не должна превышать общую площадь, так как помимо кухни есть и другие помещения - кладовая, балконы, санузел и тд, которые не входят в жилую площадь. Найдем такие квартиры:

# In[105]:


data.query('kitchen_area + living_area > total_area')['kitchen_area'].count()


# Всего таких квартир 205. Удалим данные объявления, так как корректно поменять их достаточно сложно:

# In[106]:


data = data.query('kitchen_area + living_area < total_area')


# - Рассмотрим значения столбца last_price:

# In[107]:


data['last_price'].describe()


# Мнимальное значение столбца last_price составляет около 12 тысяч. Разделим значения столбца last_price на 1000, чтобы было удобнее работать:

# In[108]:


data['last_price'] = data['last_price'] / 1000


# In[109]:


# Выведем гистограмму для last_price
sns.histplot(data['last_price'],  
            color=sns.color_palette('deep')[0], 
            bins=100
)
sns.set_style("whitegrid")
plt.xlabel('Price')
plt.ylabel("Values")
plt.title('Histogram')


# In[110]:


# Выведем диаграмму размаха для last_price
sns.boxplot(data['last_price'],
            color=sns.color_palette('deep')[0])
sns.set_style("whitegrid")
plt.ylabel("Values")
plt.title('Box-and-whiskers diagram')


# Средняя стоимость квадратного метра в Ленинградской области в 2019 году составляла около 45 тысяч. Найдем приблизительное минимальное значение цены квартиры с минимальным размером жилья:

# In[111]:


min(data['last_price']) * 45


# Оставим в выборке цены на жилье от 550 тысяч. Судя по графику, есть квартиры от 100 млн рублей, исключим их из выборки, так как их не много и они сильно выбиваются из общей выборки:

# In[112]:


data = data.query('last_price > 550 and last_price < 100000')


# - Рассмотрим значения столбца rooms:

# In[113]:


data['rooms'].describe()


# In[114]:


# Посчитаем, в скольких объявлениях значение комант нулевое
len(data.query('rooms == 0'))


# Рассмотрим объявления, в которых количество комнат равно нулю:

# In[115]:


data.query('rooms == 0')[['studio', 'is_apartment', 'open_plan']].query('studio or is_apartment or open_plan').count()


# В тех объявлениях, в которых указано нулевое значение комнат, относятся по типу либо к апартаментам, либо к студии, либо имеют свободную планировку. В данном случае оставим нулевые значения.

# In[116]:


data.query('rooms > 10')


# In[117]:


sns.histplot(data['rooms'],  
            color=sns.color_palette('deep')[0], 
            bins=100
)
sns.set_style("whitegrid")
plt.xlabel('Rooms quantity')
plt.ylabel("Values")
plt.title('Histogram')


# Также избавимся от объявлений, в которых количество комнат больше 8 (по гистограмме таких значений очень мало):

# In[118]:


data = data.query('rooms < 8')


# **Вывод:**
# 
# **Преобразование данных**
# - преобразовали типы данных в столбцах `balcony`, `days_exposition` к целочисленному.
# - добавили новые столбцы: цена за квадратный метр, день недели, месяц и год даты публикации
# - добавили столбец `type_floor` с категориями 'первый', 'последний', 'другой' в зависимость, на каком этаже расположена квартира
# - перевели значения столбца `cityCenters_nearest` из метров в километры
# 
# **Удаление аномальных и выбивающихся значений**
# - удалили 86 пропущенных значений в столбце `floors_total`
# - удалили 205 квартир, в которых сумма площадей кухни и жилой площади превосходит общую площадь
# - отесеяли значения столбца last_price до 550 тысяч и от 100 млн
# - удалили объявления, в которых количество комнат больше 8

# ### 4. Проведем исследовательский анализ данных

# ### 4.1 Изучим следующие столбцы:

# - общая площадь

# In[119]:


data['total_area'].describe()


# In[120]:


figure_two('total_area', True)


# Распределение можно назвать нормальным. При этом судя по диаграмме размаха есть выбросы от 120 метров, а по гистограмме наблюдается "хвост" из квартир с общей площадью от 300 кв.м, их немного, избавимся от них:

# In[121]:


data = data.query('total_area < 300')


# In[122]:


data['total_area'].value_counts().head(10)


# In[123]:


figure_two('total_area', True)


# **Вывод: В итоге, остались квартиры с площадью от 14 до 297,5 кв.м, медианное и среднее значения - 52 кв.м и 59 кв.м. соответственно. Квартир от 200 кв.м. немного, цены у таких квартир соответственно высокие. Типичные значения - от 40 до 46 кв.м**

# - жилая площадь;

# In[124]:


data['living_area'].describe()


# In[125]:


figure_two('living_area', True)


# In[126]:


data['living_area'].value_counts().head(10)


# **Вывод: Выборка не является однородной, распределение похоже на бимодальное. Самое частотное значение в выборке - 18 кв.м. По нормативам 18 кв.м. необходимо на каждого члена семьи из 3 и более человек, а 33 кв.м. - на одного человека. Эти нормативы могут разниться, пики как раз приходятся на значения 16-20 кв.м. и 29-32 кв.м.**

# - площадь кухни

# In[127]:


data['kitchen_area'].describe()


# In[128]:


data['kitchen_area'].value_counts().head(10)


# In[129]:


figure_two('kitchen_area', True)


# **Вывод: Минимальное значение площади кухни - 0, что подтверждается графиками. Данное значение наблюдается у квартир со свободной планировкой, студий и апартаментов. Типичные значения площади - 6-10 кв.м.**

# - цена объекта

# In[130]:


data['last_price'].describe()


# In[131]:


data['last_price'].value_counts().head(10)


# In[132]:


sns.histplot(data['last_price'],  
            color=sns.color_palette('deep')[0], 
            bins=100,
            kde=True
)
sns.set_style("whitegrid")
plt.xlabel('Price')
plt.ylabel("Values")
plt.title('Histogram')


# **Вывод: Распределение выборки нормальное. Диапазон значений - от 560 тысяч до 99 миллионов. Наиболее типичные значения - 3,5-4,6 миллиона.**

# - количество комнат

# In[133]:


data['rooms'].describe()


# In[134]:


data['rooms'].value_counts().head(10).sort_values(ascending=False)


# In[135]:


figure_two('rooms', False)


# **Вывод: В выборке наиболее часто встречающиеся квартиры - однокомнатные и двухкомнатные - 7838 и 7851 значений соотвественно. Квартир с 4 комнатами значительно меньше, чем 3 комнатами. 5-6-7-комнатных квартир достаточно мало.**

# - высота потолков

# In[136]:


data['ceiling_height'].describe()


# In[137]:


data['ceiling_height'].value_counts().head(10).sort_values(ascending=False)


# In[138]:


sns.histplot(data['ceiling_height'],  
            color=sns.color_palette('deep')[0], 
            bins=100,
            kde=True
)
sns.set_style("whitegrid")
plt.xlabel('Price')
plt.ylabel("Values")
plt.title('Histogram')


# **Вывод: Диапазон значений потолков - от 2,5 до 14 метров. Медианное значение и самое частотное значение - 2.65 метров. Также достаточно много квартир с высотой потолка 2,5-2,7 метров.**

# - этаж квартиры

# In[139]:


data['floor'].describe()


# In[140]:


data['floor'].value_counts().head(10).sort_values(ascending=False)


# In[141]:


figure_two('floor', True)


# **Вывод: Диапазон этажей - от 1 до 33. Больше всего квартир, которые располагаются на 1-5 этажах. Квартир на этажах от 10 намного меньше. Скорее всего причина в том, что в Санкт-Петербурге не так много высотных зданий, а выборка состоит примерно на 70% на объявлениях именно из Санкт-Петербурга.**

# - тип этажа квартиры («первый», «последний», «другой»)

# In[142]:


data['type_floor'].value_counts().head(10).sort_values(ascending=False).reset_index()


# In[143]:


sns.histplot(data['type_floor'],  
            color=sns.color_palette('deep')[0], 
            bins=100
)
sns.set_style("whitegrid")
plt.xlabel('Price')
plt.ylabel("Values")
plt.title('Histogram')


# **Вывод: Больше всего квартир на "других" этажах - целых 17102. В выборке большая часть квартир располагается на 1-5 этажах, из них большая часть относится именно к категории "другие". Квартир на последнем этаже чуть больше - 3249, чем квартир на первом - 2858.**

# - общее количество этажей в доме 

# In[144]:


data['floors_total'].describe()


# In[145]:


data['floors_total'].value_counts().head(10).sort_values(ascending=False)


# In[146]:


figure_two('floors_total', True)


# **Вывод: В выборке наблюдается этажность от 1 до 60. Медианное значение - 9 этажей.**
# 
# **Распределение неоднородно, наблюдется несколько пиков. Больше всего пятиэтажных домов, чуть меньше девятиэтажных. Гораздо меньше домов от 30 этажей.**

# - расстояние до центра города в метрах 

# In[147]:


data['cityCenters_nearest'].describe()


# In[148]:


data['cityCenters_nearest'].value_counts().head(10).sort_values(ascending=False)


# In[149]:


data.head()['cityCenters_nearest']


# In[150]:


figure_two('cityCenters_nearest', True)


# **Вывод: Квартиры расположены в 0-66 километрах от центра. Скорее всего, квартиры с нулевым значением, располагаются в пределах 1 км к центру. Чаще всего квартиры располагаются в 11-16 км от центра.**

# - расстояние до ближайшего аэропорта

# In[151]:


data['airports_nearest'].describe()


# In[152]:


data['airports_nearest'].value_counts().head(10).sort_values(ascending=False)


# In[153]:


data.query('airports_nearest == 0')['airports_nearest'].count()


# In[154]:


sns.histplot(data['airports_nearest'],  
            color=sns.color_palette('deep')[0], 
            bins=100
)
sns.set_style("whitegrid")
plt.xlabel('Price')
plt.ylabel("Values")
plt.title('Histogram')


# **Вывод: Квартиры расположены в 0-85 километрах от аэропорта. Скорее всего, квартира с нулевым значением располагается в аэропорту. Медианное значение - 26,7 км.**

# - расстояние до ближайшего парка

# In[155]:


data['parks_nearest'].describe()


# In[156]:


data['parks_nearest'].value_counts().head(10).sort_values(ascending=False)


# In[157]:


figure_two('parks_nearest', False)


# **Вывод: Парки расположены в 1-3190 метрах от квартир. Медианное значение - 455 метров.**

# - день публикации объявления

# In[158]:


data['day_of_week'].describe()


# In[159]:


data['day_of_week'].value_counts().sort_values(ascending=False)


# In[160]:


figure_two('day_of_week', False)


# **Вывод: Чаще всего публикации о продаже происходят в четверг, чуть реже во вторник. В субботу и воскресенье публикаций намного меньше, чем в будние дни. Похоже, что в выходные дни активность пользователей снижается.**

# - месяц публикации объявления

# In[161]:


data['month'].describe()


# In[162]:


data['month'].value_counts().sort_values(ascending=False)


# In[163]:


figure_two('month', False)


# **Вывод: Чаще всего публикации о продаже происходят в феврале, марте и апреле. Меньше всего публикаций отмечается в январе, мае и декабре. Получается, что существует некая сезонность для продаж квартир: с февраля по апрель и с сентября по ноябрь - самая высокая активность.**

# ### 4.2 Изучим, как быстро продавались квартиры (столбец days_exposition)

# In[164]:


data['days_exposition'].describe()


# In[165]:


data['days_exposition'].value_counts().head(10).sort_values(ascending=False)


# In[166]:


figure_two('days_exposition', True)


# Квартиры продавались от 0 до 1618 дней. Медианное и среднее значение составляет 95 и 186 соотвественно. Как отмечали выше, наиболее часто встречающиеся значения выпали на 45 (1,5 месяца), 60 (месяц), 7 (неделя), 30 (месяц), 90 дней (три месяца). Возможно, что существует функция, которая может снимать публикации после определенного времени. Если это так, то достаточно сложно разделить квартиры, которые действительно продались в эти дни и которые были сняты автоматически. Попробуем убрать эти дни из выборки и посмотрим как изменились характеристики (также не будем включать нулевые значения - возможно, что такие квартиры либо продались в тот же день, либо сами авторы удалили свою публикацию):

# In[167]:


data.query('days_exposition != [45, 60, 7, 30, 90, 0]')['days_exposition'].describe()


# In[168]:


data.query('days_exposition != [45, 60, 7, 30, 90, 0]')['days_exposition'].value_counts().head(10).sort_values(ascending=False)


# In[169]:


sns.histplot(data.query('days_exposition != [45, 60, 7, 30, 90]')['days_exposition'],  
            color=sns.color_palette('deep')[0], 
            bins=100,
             kde=True
)
sns.set_style("whitegrid")
plt.xlabel('Price')
plt.ylabel("Values")
plt.title('Histogram')


# Распределение стало больше похожена распределение Пуассона. Удалять публикации с днями 45 (1,5 месяца), 60 (месяц), 7 (неделя), 30 (месяц), 90 дней (три месяца) не будем, так как неизвестно, как отделить  квартиры, которые действительно продались в эти дни и которые были сняты автоматически. При этом, удаляя данные значения, можно исказить данные в целом. Необходимо запросить дополнительную информацию о природе значений данного столбца.

# In[170]:


sns.boxplot(data.query('days_exposition != [45, 60, 7, 30, 90, 0]')['days_exposition'],
            color=sns.color_palette('deep')[0])
sns.set_style("whitegrid")
plt.ylabel("Values")
plt.title('Box-and-whiskers diagram')


# Среднее значение после фильтрации составляет 200 дней, медианное значение - 112 дней. Данные значения сильно отличаются из-за того, что очень много значений лежит от 1000 дней и это влияет на величину среднего.
# 
# Определим, какие продажи можно отнести к быстрым и долгим.
# 
# Исходя из диаграммы размаха, наблюдаются выбросы выше значения верхней границы. Найдем значение вехней границы:

# In[171]:


data.query('days_exposition != [45, 60, 7, 30, 90, 0]')['days_exposition'].quantile(0.75) + 1.5 * (data.query('days_exposition != [45, 60, 7, 30, 90, 0]')['days_exposition'].quantile(0.75) - data.query('days_exposition != [45, 60, 7, 30, 90, 0]')['days_exposition'].quantile(0.25)) 


# In[208]:


# Посчитаем, сколько всего публикаций было продано более чем за 593 дня
data.query('days_exposition > 593')['days_exposition'].count()


# 1499 объявления продавались более чем за 593 дня. Будем считать, что все, что находится выше данного значения, относится к долгим продажам, то есть публикации от 593 дней можно назвать необычно долгими.

# ### 4.3 Изучим, какие факторы больше всего влияют на общую (полную) стоимость объекта

# In[173]:


data.corr()['last_price'].sort_values(ascending=False)


# **Выраженная корреляция наблюдается наблюдается у цены и столбцов total_area(общая площадь), square_meter_price(цена за квадратный метр), living_area(жилая площадь), kitchen_area(площадь кухни), rooms(количество комнат)**

# - Зависимость цены от общей площади:

# In[174]:


data['last_price'].corr(data['total_area'])


# In[175]:


sns.scatterplot(data=data, x='total_area', y='last_price', color=sns.color_palette('deep')[0])
sns.set_style("whitegrid")
plt.xlabel('Total area')
plt.ylabel("Price")
plt.title('Scatter plot')


# Коэффициент корреляции между значениями цены и общей площади составляет 0,75. До значения общей площади 150 кв.м. наблюдается сильная корреляция, после 150 кв.м. отклонение становится больше.

# - Зависимость цены от жилой площади

# In[176]:


data['last_price'].corr(data['living_area'])


# In[177]:


sns.scatterplot(data=data, x='living_area', y='last_price', color=sns.color_palette('deep')[0])
sns.set_style("whitegrid")
plt.xlabel('Living area')
plt.ylabel("Price")
plt.title('Scatter plot')


# Коэффициент корреляции между значениями цены и жилой площади составляет 0,66. До значения площади 100 кв.м. наблюдается сильная корреляция, после 100 кв.м. разброс значений становится больше.

# - Зависимость цены от площади кухни:

# In[178]:


data['last_price'].corr(data['kitchen_area'])


# In[179]:


sns.scatterplot(data=data, x='kitchen_area', y='last_price', color=sns.color_palette('deep')[0])
sns.set_style("whitegrid")
plt.xlabel('Kitchen area')
plt.ylabel("Price")
plt.title('Scatter plot')


# Коэффициент корреляции между значениями цены и площади кухни составляет 0,58. Достаточно много квартир с кухнями около 20 кв метров в широком ценовом диапазоне.

# - Зависимость цены от количества комнат

# In[180]:


data['last_price'].corr(data['rooms'])


# In[217]:


rooms = data.pivot_table(index='rooms', values='last_price', aggfunc='median')
rooms.columns = ['median']
rooms = rooms.reset_index()
print(rooms)


# In[182]:


sns.barplot(data=rooms, x='rooms', y='median', color=sns.color_palette('deep')[0])
sns.set_style("whitegrid")
plt.xlabel('Rooms')
plt.ylabel("Price")
plt.title('Bar plot')


# Коэффициент корреляции между значениями цены и площади кухни составляет 0,45. С Увеличением количества комнат, цена повышается.

# - Зависимость цены от этажа, на котором расположена квартира (первый, последний, другой)

# In[214]:


floors = data.pivot_table(index='type_floor', values='last_price', aggfunc='median')
floors.columns = ['median']
floors = floors.reset_index()
print(floors)


# In[184]:


sns.barplot(data=floors, x='type_floor', y='median', hue='type_floor', color=sns.color_palette('deep')[0])
sns.set_style("whitegrid")
plt.xlabel('Floor type')
plt.ylabel("Price")
plt.title('Bar plot')


# Цены на квартиры на 1 этаже ниже, чем на последних этажах. Наибольшая цена - у квартир, которые расположены между первым и последним этажом.

# - Зависимость цены от даты размещения (день недели)

# In[216]:


week = data.pivot_table(index='day_of_week', values='last_price', aggfunc='median')
week.columns = ['median']
week = week.reset_index()
print(week)


# In[202]:


sns.lineplot(data=week, x='day_of_week', y='median', color=sns.color_palette('deep')[0], marker="o")
sns.set_style("whitegrid")
plt.xlabel('Week day')
plt.ylabel("Price (median value)")
plt.title('Line plot')


# Резкий скачок цен наблюдается с понедельника на вторник. Со вторника по субботу цена уменьшается. Цены в субботу и воскресенье близки по значению. В субботу и воскресенье активность небольшая, публикаций меньше, поэтому и значение цены соотвественно ниже, чем в остальные дни.

# - Зависимость цены от даты размещения (месяц)

# In[187]:


month = data.pivot_table(index='month', values='last_price', aggfunc='median')
month.columns = ['median']
month = month.reset_index()


# In[201]:


sns.lineplot(data=month, x='month', y='median', color=sns.color_palette('deep')[0], marker="o")
sns.set_style("whitegrid")
plt.xlabel('Month')
plt.ylabel("Price (median value)")
plt.title('Line plot')


# Наибольшая цена наблюдается в апреле, после апреля до июня происходит резкое уменьшение показателя. Как отмечали выше, с февраля по апрель и с сентября по ноябрь - самая высокая активность пользоваталей. Видимо, высокая активность пользователей увеличивает число публикаций и, соттветственно, значение цены в этот месяц.

# - Зависимость цены от даты размещения (год)

# In[215]:


year = data.pivot_table(index='year', values='last_price', aggfunc='median')
year.columns = ['median']
year = year.reset_index()
print(year)


# In[199]:


sns.lineplot(data=year, x='year', y='median', color=sns.color_palette('deep')[0], marker="o")
sns.set_style("whitegrid")
plt.xlabel('Year')
plt.ylabel("Price (median value)")
plt.title('Line plot')


# С 2014 по 2016 цена непрерывно снижалась достаточно резко (за это время произошло снижение почти в 2 раза). Предположим, что это может быть связано с экономическим кризисом 2014 года - вследствие этого произошло сокращение спроса, снижение темпов строительства и т.д. С наступлением 2017 года ситуация стабилизировалась, цена стала повышаться вплоть до 2019 года.

# **Вывод:**
# **Наибольшая корреляция цены выявлена со значениями общей площади, жилой площади, площади кухни и количеством комнат с коэффициентами корреляции 0.75, 0.66, 0.58, 0.45 соответственно. Чем выше значения данных столбцов, тем цена выше.**
# 
# **Цены на квартиры на 1 этаже ниже, чем на последних этажах. Наибольшая цена - у квартир, которые расположены между первым и последним этажом.**
# 
# **Цена также зависит от:**
# - `дня недели`. Наблюдается зависимость между активностью пользователями и ценой: резкий скачок цен  с понедельника на вторник. Цены в субботу и воскресенье близки по значению. В субботу и воскресенье активность небольшая, публикаций меньше, поэтому и значение цены соотвественно ниже, чем в остальные дни.
# - `месяца`. Наибольшая цена наблюдается в апреле, после апреля до июня происходит резкое уменьшение показателя цены. Здесь также немаловажную роль играет активность пользоваталей. Видимо, высокая активность пользователей увеличивает число публикаций и, соответственно, значение цены в этот месяц.
# - `года`. С 2014 по 2016 года наблюдалось резкое снижение цены вдвое, с 2017 по 2019 год цена стала увеличиваться, практически достигнув значения 2015 года. Причина - экономическая ситуация на мировом рынке.

# ### 4.4 Посчитайте среднюю цену одного квадратного метра в 10 населённых пунктах с наибольшим числом объявлений. Выделите населённые пункты с самой высокой и низкой стоимостью квадратного метра. Эти данные можно найти по имени в столбце locality_name.

# In[191]:


locality_top = data.pivot_table(index='locality_name', values='square_meter_price', aggfunc=['count', 'mean'])
locality_top.columns = ['total', 'mean']
locality_top = locality_top.sort_values(by='total', ascending=False).head(10).reset_index()
locality_top['mean'] = round(locality_top['mean'], 2)


# In[192]:


locality_top.sort_values(by='mean')


# **Из населенных пунктов с наибольшим число объявлений самая `высокая` стоимость квадратного метра в Санкт-Петербурге - 113 383.**
# 
# **Из населенных пунктов с наибольшим число объявлений самая `низкая` стоимость квадратного метра в Выборге - 58 304.**

# ### 4.5 Выделим квартиры в Санкт-Петербурге с помощью столбца locality_name и вычислим среднюю цену каждого километра. Опишем, как стоимость объектов зависит от расстояния до центра города.

# In[193]:


data.query('locality_name == "санкт-петербург"').pivot_table(index='cityCenters_nearest', values='last_price') .sort_values(by='last_price', ascending=False)


# In[203]:


sns.lineplot(data.query('locality_name == "санкт-петербург"').pivot_table(index='cityCenters_nearest', values='last_price'),
             color=sns.color_palette('deep')[0], 
             marker='o')
sns.set_style('whitegrid')
plt.xlabel('Distance to city center')
plt.ylabel('Price (mean value)')
plt.title('Line plot')


# **Пиковое значение наблюдается в самом центре, в диапазоне от 0 до 1 км. Примерно от 7 км до 26 км цена имеет тенденцию к снижению. Также присутствуют выбивающиеся пиковые значения на расстоянии 7 и 27 км. Можно объяснить тем, что на расстоянии в 7 км располагаются много квартир с высокой ценой за 1 кв.м. - могли повлиять такие факторы, как удачное местоположение, хорошая инфраструктура, близость к метро и тд. Рассмотрим срез данных со значением в 27 км:**

# In[195]:


data.query('cityCenters_nearest == 27 & locality_name == "санкт-петербург"').sort_values(by='last_price', ascending=False)


# На расстоянии в 27 км от центра всего две квартиры, но цена одной из них (14,4 млн) значительно больше второй, что приводит к большому значению средней цены и к пику на графике.

# ### 5. Общий вывод

# Было проведено исследование данных сервиса Яндекс Недвижимость — архив объявлений за несколько лет о продаже квартир в Санкт-Петербурге и соседних населённых пунктах.
# 
# 1. В связи с большим количеством пропущенных значений были заполнены следующие столбцы: ceiling_height (высота потолков (м)) floors_total (всего этажей в доме), living_area (жилая площадь в квадратных метрах (м²)). is_apartment (апартаменты),  kitchen_area (площадь кухни в квадратных метрах (м²)), balcony (число балконов), locality_name (название населённого пункта) и days_exposition (сколько дней было размещено объявление (от публикации до снятия)). В столцах airports_nearest (расстояние до ближайшего аэропорта в метрах (м)), cityCenters_nearest (расстояние до центра города (м)), parks_around3000 (число парков в радиусе 3 км), parks_nearest (расстояние до ближайшего парка (м)), ponds_around3000 (число водоёмов в радиусе 3 км), ponds_nearest (расстояние до ближайшего водоёма (м)) - оставили пропущенные значения, так как  скорее всего они вызваны технической ошибкой.
# 
# 
# 2. Преобразовали типы данных в столбцах balcony, days_exposition к целочисленному; добавили новые столбцы - цена за квадратный метр, день недели, месяц и год даты публикации, тип этажа; перевели значения столбца cityCenters_nearest из метров в километры; удалили выбивающиеся значения last_price (до 550 тысяч и от 100 млн), rooms(количество комнат больше 8), также удалили 205 объявлений, в которых сумма площадей кухни и жилой площади превосходит общую площадь. В столбце floors_total (общее количество этажей) удалили 86 пропущенных значений.
# 
# 
# 3. В столбце days_exposition() самые частотные значения - 45 (1,5 месяца), 60 (месяц), 7 (неделя), 30 (месяц), 90 дней (три месяца). Возможно, что существует функция, которая может снимать/архивировать публикации после определенного количества времени. По диаграмме размаха определили, что необычно долгими публикацими можно считать те, которые "висят" более 593 дней.
# 
# 
# 4. Нашли зависимости стоимость квартир от различных факторов:
# - Наибольшая корреляция цены выявлена со значениями общей площади, жилой площади, площади кухни и количеством комнат с коэффициентами корреляции 0.75, 0.66, 0.58, 0.45 соответственно. Чем выше значения данных столбцов, тем цена выше.
# - Цены на квартиры на 1 этаже ниже, чем на последних этажах. Наибольшая цена - у квартир, которые расположены между первым и последним этажом.
# - Наблюдается зависимость между активностью пользователями и ценой: резкий скачок цен с понедельника на вторник. В субботу и воскресенье активность небольшая, публикаций меньше, поэтому и значение цены соотвественно ниже, чем в остальные дни. В целом, в будние дни цена выше, чем в выходные.
# - Наибольшая цена наблюдается в апреле, после апреля до июня происходит резкое уменьшение показателя цены. Здесь также немаловажную роль играет активность пользоваталей. Видимо, высокая активность пользователей увеличивает число публикаций и, соответственно, значение цены в этот месяц.
# - С 2014 по 2016 года наблюдалось резкое снижение цены вдвое (c 8,118.5 до 4,450 млн), с 2017 по 2019 год цена стала увеличиваться, практически достигнув значения 2015 года. Причина в резком падении цен с 2014 - экономическая ситуация на мировом рынке.
#  
#  
# 5. Стоимость объектов ближе к центру Санкт-Петербурга увеличивается, самая большая стоимость - в пределах одного километра и на расстоянии в 7 км. Самая высокая стоимость квадратного метра - в Санкт Перербурге.
# 
# 
# Рекомендации:
# - Устранить техническую ошибку, при которой в столбцах airports_nearest (расстояние до ближайшего аэропорта в метрах (м)), cityCenters_nearest (расстояние до центра города (м)), parks_around3000 (число парков в радиусе 3 км), parks_nearest (расстояние до ближайшего парка (м)), ponds_around3000 (число водоёмов в радиусе 3 км), ponds_nearest (расстояние до ближайшего водоёма (м)) значения остаются не зполненными.
# - Отделить объявления, которые были архивированы автоматически в дни 45 (1,5 месяца), 60 (месяц), 7 (неделя), 30 (месяц), 90 дней (три месяца) от тех квартир, которые были проданы именно в эти дни.
# - Также стоит отдельно рассмотреть, как изменялась цена на квартиры по годам в зависимости от населенных пунктов и более подробно зависимость цены от других факторов, так как в данном исследовании опирались на значение коэффициента Пирсона, которое может не отражать более сложные зависимости.
